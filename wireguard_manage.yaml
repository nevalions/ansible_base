---
- name: Manage WireGuard network
  hosts: wireguard_cluster
  # hosts: wireguard_servers
  # hosts: wireguard_clients
  become: true
  gather_facts: true
  serial: 1
  vars_files:
    - vault_secrets.yml
  tags:
    - wireguard
    - vpn
  vars:
    wg_operation: "install"

  tasks:
    - name: Display operation
      ansible.builtin.debug:
        msg: "WireGuard operation: {{ wg_operation }}"

    - name: Ensure WireGuard peer keys are defined in vault
      ansible.builtin.assert:
        that:
          - vault_wg_peer_private_keys is defined
          - vault_wg_peer_private_keys is not none
          - vault_wg_peer_private_keys | length > 0
          - vault_wg_peer_public_keys is defined
          - vault_wg_peer_public_keys is not none
          - vault_wg_peer_public_keys | length > 0
        fail_msg: |
          WireGuard peer keys or pod subnet are not defined in vault_secrets.yml.
          Please generate keys and set the pod subnet:

          Option 1: Use the key generation script
          bash generate_wg_keys.sh > wg_keys.yaml

          Option 2: Generate keys manually
          # Generate peer keys for each peer and add to vault:
          vault_wg_peer_private_keys:
            [PEER_NAME]: "<private key for [PEER_NAME]>"
            # ... add other peers
          vault_wg_peer_public_keys:
            [PEER_NAME]: "<public key for [PEER_NAME]>"
            # ... add other peers

          For complete setup instructions, see WIREGUARD_SETUP.md
        success_msg: "WireGuard peer keys found in vault"

    - name: Ensure Kubernetes VIP and pod subnet are defined
      ansible.builtin.assert:
        that:
          - vault_k8s_api_vip is defined
          - vault_k8s_api_vip is not none
          - vault_k8s_api_vip | string | length > 0
          - vault_k8s_api_port is defined
          - vault_k8s_api_port is not none
          - vault_k8s_api_port | string | length > 0
          - vault_k8s_pod_subnet is defined
          - vault_k8s_pod_subnet is not none
          - vault_k8s_pod_subnet | string | length > 0
        fail_msg: |
          Kubernetes VIP, API port, or pod subnet are not defined in vault_secrets.yml.
          Set these values before running this playbook:

          - vault_k8s_api_vip
          - vault_k8s_api_port
          - vault_k8s_pod_subnet
        success_msg: "Kubernetes VIP, API port, and pod subnet found in vault"

    - name: Build WireGuard allowed networks list with pod subnet
      ansible.builtin.set_fact:
        wg_allowed_networks_merged: "{{ (vault_wg_allowed_networks | default([])) + [vault_k8s_pod_subnet] | unique }}"

    # Routing design for Traefik real-client-IP with externalTrafficPolicy: Local
    #
    # Root cause of previous failure:
    #   bay_plane1 (is_server: true) had vault_wg_routed_cidrs which included the
    #   MetalLB pool CIDR (11.11.0.0/24). WireGuard's kernel scope-link route
    #   (distance 0) for that CIDR beat the FRR BGP routes (distance 20).
    #   Result: traffic to 11.11.0.1 went via plane1's WG tunnel — plane1 has no
    #   Traefik pod, so connections failed with HTTP 000.
    #
    # Fix applied here:
    #   - MetalLB pool CIDR is NEVER added to any WireGuard peer's AllowedIPs.
    #     Both HAProxy and bay_bgp learn 11.11.0.0/24 via FRR BGP from workers.
    #     BGP routes resolve to correct worker nodes (9.11.0.22, .31, .39, .41).
    #   - Worker peers get pod CIDR (10.244.0.0/16) in AllowedIPs on HAProxy.
    #     After MASQUERADE on workers, Traefik pod replies arrive at HAProxy from
    #     worker WG IPs — but HAProxy needs 10.244.0.0/16 routed via workers to
    #     accept the inbound packets correctly.
    #   - vault_wg_routed_cidrs is set to [] — legacy is_server mechanism disabled.

    - name: Normalize MetalLB pool CIDR
      ansible.builtin.set_fact:
        wg_metallb_pool_cidr_normalized: >-
          {{
            vault_metallb_pool_cidr
            if (vault_metallb_pool_cidr | string) is search('/')
            else (vault_metallb_pool_cidr | string) + '/24'
          }}

    # Build per-peer extra AllowedIPs using the wg_routing_filters plugin.
    # build_peers_extra_cidrs(peers, groups, bgp_hosts, worker_hosts, metallb_cidr, pod_cidr, db_route, db_hosts)
    #
    # Routing ownership rules (replaces legacy is_server + vault_wg_routed_cidrs):
    #   MetalLB CIDR → intentionally omitted from WG (BGP routes used; WG link-route would override)
    #   Pod CIDR     → intentionally omitted from WG (MASQUERADE on workers rewrites to worker /32)
    #   DB WG route  → only added when DB has no dedicated peer entry (avoids AllowedIPs conflict)
    - name: Build per-peer extra CIDRs (explicit routing ownership)
      ansible.builtin.set_fact:
        wg_computed_peers_extra_cidrs: >-
          {{
            vault_wg_peers | default([])
            | build_peers_extra_cidrs(
                groups,
                groups.get('bgp_routers', []),
                groups.get('kuber_small_workers', []) + groups.get('vas_workers_all', []),
                wg_metallb_pool_cidr_normalized,
                vault_k8s_pod_subnet,
                vault_db_wg_route_cidr | default(''),
                groups.get('db', [])
              )
          }}

    - name: Debug computed peer extra CIDRs
      ansible.builtin.debug:
        msg: "Per-peer extra CIDRs: {{ wg_computed_peers_extra_cidrs }}"

    - name: Assert no duplicate CIDRs within a peer entry
      ansible.builtin.assert:
        that:
          - item.value | length == (item.value | unique | list | length)
        fail_msg: "Duplicate CIDRs for peer {{ item.key }}: {{ item.value }}"
        success_msg: "No duplicate CIDRs for peer {{ item.key }}"
      loop: "{{ wg_computed_peers_extra_cidrs | dict2items }}"

    - name: Set WireGuard routed CIDRs (legacy - empty; all routing is now explicit)
      ansible.builtin.set_fact:
        wg_routed_cidrs: []
        # vault_wg_masquerade_dst: WG IP of the ingress/HAProxy node.
        # Defined here so worker PostUp/PreDown rules can reference it without
        # embedding a hardcoded dict key. Override via vault_wg_masquerade_dst in vault.
        vault_wg_masquerade_dst: "{{ vault_wg_masquerade_dst | default(vault_wg_server_ips.values() | list | first) }}"
      # vault_wg_peers_extra_cidrs takes full ownership of CIDRs.
      # The legacy is_server + vault_wg_routed_cidrs path in templates is
      # now a no-op (empty list), preventing unintended route ownership.

    - name: Set masquerade PostUp/PreDown rules for worker nodes
      # Workers need MASQUERADE so Traefik pod reply traffic (pod CIDR src)
      # is SNATed to the worker's own WireGuard IP before going back to the HAProxy node.
      # Required when externalTrafficPolicy: Local is used (kube-proxy does not masquerade).
      # vault_wg_masquerade_dst: WG IP of the HAProxy/ingress node (from vault_wg_server_ips)
      ansible.builtin.set_fact:
        wg_worker_postup_rules: >-
          {{
            vault_wg_worker_postup_rules | default([
              'iptables -t nat -A POSTROUTING -s ' + vault_k8s_pod_subnet + ' -d ' + vault_wg_masquerade_dst + ' -j MASQUERADE'
            ])
            if inventory_hostname in (
              groups.get('kuber_small_workers', []) +
              groups.get('vas_workers_all', [])
            )
            else []
          }}
        wg_worker_predown_rules: >-
          {{
            vault_wg_worker_predown_rules | default([
              'iptables -t nat -D POSTROUTING -s ' + vault_k8s_pod_subnet + ' -d ' + vault_wg_masquerade_dst + ' -j MASQUERADE'
            ])
            if inventory_hostname in (
              groups.get('kuber_small_workers', []) +
              groups.get('vas_workers_all', [])
            )
            else []
          }}

    - name: Apply WireGuard role
      ansible.builtin.include_role:
        name: wireguard
      vars:
        vault_wg_allowed_networks: "{{ wg_allowed_networks_merged }}"
        # Legacy vault_wg_routed_cidrs is now empty - all CIDRs are explicit via
        # vault_wg_peers_extra_cidrs. This prevents is_server peers from
        # accidentally claiming MetalLB pool routes.
        vault_wg_routed_cidrs: "{{ wg_routed_cidrs }}"
        # Explicit per-peer extra CIDRs (authoritative):
        #   - BGP router peers get MetalLB pool CIDR (HAProxy routes via FRR)
        #   - Worker peers get pod CIDR (return path for Traefik pod replies)
        vault_wg_peers_extra_cidrs: "{{ wg_computed_peers_extra_cidrs }}"
        wg_postup_rules: "{{ wg_worker_postup_rules }}"
        wg_predown_rules: "{{ wg_worker_predown_rules }}"

    - name: Check if dnsmasq service exists
      ansible.builtin.systemd:
        name: dnsmasq
      register: dnsmasq_service_status
      failed_when: false
      changed_when: false

    - name: Set fact for dnsmasq presence
      ansible.builtin.set_fact:
        has_dnsmasq: "{{ dnsmasq_service_status.status is defined and dnsmasq_service_status.status.LoadState == 'loaded' }}"

    - name: Set fact for dnsmasq restart requirement
      ansible.builtin.set_fact:
        dnsmasq_needs_restart: >-
          {{
            (wg_config_deployed.changed | default(false))
            or ((dnsmasq_service_status.status.ActiveState | default('inactive')) != 'active')
          }}
      when:
        - has_dnsmasq | default(false)
        - not ansible_check_mode

    - name: Wait for WireGuard interface to be fully up before restarting dnsmasq
      ansible.builtin.wait_for:
        timeout: 3
      when:
        - has_dnsmasq | default(false)
        - dnsmasq_needs_restart | default(false)
        - not ansible_check_mode

    - name: Read dnsmasq config before restart validation
      ansible.builtin.slurp:
        path: "{{ dns_client_dnsmasq_config_path | default('/etc/dnsmasq.d/99-k8s-filter-aaaa.conf') }}"
      register: dnsmasq_config_raw
      failed_when: false
      changed_when: false
      when:
        - has_dnsmasq | default(false)
        - dnsmasq_needs_restart | default(false)
        - not ansible_check_mode

    - name: Extract dnsmasq listen IP from config
      ansible.builtin.set_fact:
        dnsmasq_listen_ip: >-
          {{
            ((dnsmasq_config_raw.content | default('') | b64decode)
              | regex_findall('(?m)^listen-address=([0-9.]+)$')
              | first)
            | default('')
          }}
      when:
        - has_dnsmasq | default(false)
        - dnsmasq_needs_restart | default(false)
        - not ansible_check_mode

    - name: Get current host IPv4 addresses for dnsmasq restart check
      ansible.builtin.command: ip -4 -o addr show
      register: host_ipv4_addresses_show
      changed_when: false
      failed_when: false
      when:
        - has_dnsmasq | default(false)
        - dnsmasq_needs_restart | default(false)
        - not ansible_check_mode

    - name: Set dnsmasq listen address presence fact
      ansible.builtin.set_fact:
        dnsmasq_listen_ip_present: >-
          {{
            (dnsmasq_listen_ip | length > 0)
            and (dnsmasq_listen_ip in (
              host_ipv4_addresses_show.stdout
              | regex_findall('inet\\s+([0-9.]+)/')
              | unique
              | list
            ))
          }}
      when:
        - has_dnsmasq | default(false)
        - wg_config_deployed.changed | default(false)
        - not ansible_check_mode

    - name: Restart dnsmasq after WireGuard config change
      ansible.builtin.systemd:
        name: dnsmasq
        state: restarted
      when:
        - has_dnsmasq | default(false)
        - dnsmasq_needs_restart | default(false)
        - dnsmasq_listen_ip_present | default(false)
        - not ansible_check_mode

    - name: Skip dnsmasq restart when configured listen IP is missing
      ansible.builtin.debug:
        msg: >-
          Skipping dnsmasq restart on {{ inventory_hostname }} because listen-address
          {{ dnsmasq_listen_ip | default('UNSET') }} is not present on this host.
      when:
        - has_dnsmasq | default(false)
        - dnsmasq_needs_restart | default(false)
        - not (dnsmasq_listen_ip_present | default(false))
        - not ansible_check_mode

    - name: Notify dnsmasq restart
      ansible.builtin.debug:
        msg: "dnsmasq restarted on {{ inventory_hostname }} after WireGuard configuration change"
      when:
        - has_dnsmasq | default(false)
        - dnsmasq_needs_restart | default(false)
        - dnsmasq_listen_ip_present | default(false)
        - not ansible_check_mode

    - name: Check if this host is a control plane or BGP router
      ansible.builtin.set_fact:
        is_control_plane: "{{ inventory_hostname in (groups.planes_all | default([])) }}"
        is_bgp_router: "{{ inventory_hostname in (groups.bgp_routers | default([])) }}"

    - name: Check if keepalived service exists
      ansible.builtin.systemd:
        name: keepalived
      register: keepalived_service_status
      failed_when: false
      changed_when: false
      when:
        - (is_control_plane | default(false)) or (is_bgp_router | default(false))
        - not ansible_check_mode

    - name: Set fact for keepalived service presence
      ansible.builtin.set_fact:
        has_keepalived: >-
          {{
            keepalived_service_status.status is defined
            and keepalived_service_status.status.LoadState == 'loaded'
          }}
      when:
        - (is_control_plane | default(false)) or (is_bgp_router | default(false))
        - not ansible_check_mode

    - name: Check if FRR service exists
      ansible.builtin.systemd:
        name: frr
      register: frr_service_status
      failed_when: false
      changed_when: false
      when:
        - is_bgp_router | default(false)
        - not ansible_check_mode

    - name: Set fact for FRR service presence
      ansible.builtin.set_fact:
        has_frr: "{{ frr_service_status.status is defined and frr_service_status.status.LoadState == 'loaded' }}"
      when:
        - is_bgp_router | default(false)
        - not ansible_check_mode

    - name: Restart Keepalived on control planes after WireGuard config change
      ansible.builtin.systemd:
        name: keepalived
        state: restarted
      when:
        - is_control_plane | default(false)
        - has_keepalived | default(false)
        - wg_config_deployed.changed | default(false)
        - not ansible_check_mode

    - name: Skip Keepalived restart on control plane when service is missing
      ansible.builtin.debug:
        msg: "Skipping Keepalived restart on {{ inventory_hostname }} because keepalived service is not installed"
      when:
        - is_control_plane | default(false)
        - not (has_keepalived | default(false))
        - wg_config_deployed.changed | default(false)
        - not ansible_check_mode

    - name: Notify Keepalived restart on control plane
      ansible.builtin.debug:
        msg: "Keepalived restarted on {{ inventory_hostname }} after WireGuard configuration change"
      when:
        - is_control_plane | default(false)
        - wg_config_deployed.changed | default(false)
        - not ansible_check_mode

    - name: Restart FRR on BGP routers after WireGuard config change
      ansible.builtin.systemd:
        name: frr
        state: restarted
      when:
        - is_bgp_router | default(false)
        - has_frr | default(false)
        - wg_config_deployed.changed | default(false)
        - not ansible_check_mode

    - name: Skip FRR restart on BGP router when service is missing
      ansible.builtin.debug:
        msg: "Skipping FRR restart on {{ inventory_hostname }} because frr service is not installed"
      when:
        - is_bgp_router | default(false)
        - not (has_frr | default(false))
        - wg_config_deployed.changed | default(false)
        - not ansible_check_mode

    - name: Restart Keepalived on BGP routers after WireGuard config change
      ansible.builtin.systemd:
        name: keepalived
        state: restarted
      when:
        - is_bgp_router | default(false)
        - has_keepalived | default(false)
        - wg_config_deployed.changed | default(false)
        - not ansible_check_mode

    - name: Skip Keepalived restart on BGP router when service is missing
      ansible.builtin.debug:
        msg: "Skipping Keepalived restart on {{ inventory_hostname }} because keepalived service is not installed"
      when:
        - is_bgp_router | default(false)
        - not (has_keepalived | default(false))
        - wg_config_deployed.changed | default(false)
        - not ansible_check_mode

    - name: Notify BGP services restart
      ansible.builtin.debug:
        msg: "FRR and Keepalived restarted on BGP router {{ inventory_hostname }} after WireGuard configuration change"
      when:
        - is_bgp_router | default(false)
        - has_frr | default(false)
        - has_keepalived | default(false)
        - wg_config_deployed.changed | default(false)
        - not ansible_check_mode
