---
# Kubernetes Network Configuration (from vault)
kubeadm_pod_subnet: "{{ vault_k8s_pod_subnet }}"
kubeadm_service_subnet: "{{ vault_k8s_service_subnet }}"

# Use DNS or VIP as control plane endpoint for worker joins
# Priority: DNS (if enabled) -> VIP -> empty
kubeadm_control_plane_endpoint_host: >-
  {{
    (vault_k8s_api_dns | default(''))
    if (vault_k8s_use_dns_endpoint | default(false))
    else (vault_k8s_api_vip | default(''))
  }}
kubeadm_control_plane_endpoint: "{{ kubeadm_control_plane_endpoint_host }}:{{ vault_k8s_api_port }}"

# Advertise WireGuard IP for internal communication
# Dynamically finds current host's IP from vault_k8s_control_planes list
# Falls back to ansible_default_ipv4.address if not found
kubeadm_api_server_advertise_address: >-
  {{
    (vault_k8s_control_planes
      | selectattr('name', 'equalto', inventory_hostname)
      | map(attribute='wireguard_ip')
      | list
      | first)
    | default(
        ansible_facts.get(vault_keepalived_vip_interface | default('wg99'), {}).get('ipv4', {}).get('address', '')
      )
    | default(ansible_default_ipv4.address)
  }}

kubeadm_kubelet_extra_args:
  node-ip: "{{ kubeadm_api_server_advertise_address }}"

# Ensure API server certificate includes all control-plane endpoints
# Includes DNS names when DNS endpoint is enabled
kubeadm_api_server_cert_sans: >-
  {{
    (
      [
        kubeadm_control_plane_endpoint_host,
        kubeadm_api_server_advertise_address,
        (vault_k8s_api_dns_name ~ '.' ~ vault_dns_zone) if (vault_k8s_api_dns_name is defined) else ''
      ]
      + (vault_k8s_control_planes | default([]) | map(attribute='wireguard_ip') | list)
      + (vault_k8s_control_planes | default([]) | map(attribute='name') | list)
      + (vault_k8s_control_planes | default([]) | map(attribute='dns_name') | list if (vault_k8s_control_planes[0].dns_name is defined) else [])
      + ([vault_k8s_api_dns_name] if (vault_k8s_api_dns_name is defined) else [])
      + (vault_k8s_control_planes | default([]) | map(attribute='dns_name') | list | map('regex_replace', '^(.*)$', '\\1.' ~ vault_dns_zone) | list if (vault_k8s_control_planes[0].dns_name is defined) else [])
    )
    | reject('equalto', '')
    | select('match', '^(?:\\d{1,3}\\.){3}\\d{1,3}$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$')
    | unique
    | list
  }}

kubeadm_api_version: "v1beta4"

# Kubeconfig Configuration
kubeconfig_user: "{{ vault_admin_user | default(ansible_user | default(ansible_user_id)) }}"
# Avoid relying on top-level injected facts (ansible_env.*).
kubeconfig_user_home: "{{ ansible_facts.get('env', {}).get('HOME', ansible_user_dir | default('/home/' ~ kubeconfig_user)) }}"
kubeconfig_path: "{{ kubeconfig_user_home }}/.kube/config"

# Refresh API server certs and kubeconfig on re-run
kubeadm_refresh_on_existing: true

# Node Feature Discovery (NFD) for node system metadata in Kubernetes/K9s
k8s_node_info_enabled: true
nfd_version: "v0.18.2"
nfd_kustomize_ref: "https://github.com/kubernetes-sigs/node-feature-discovery/deployment/overlays/default?ref={{ nfd_version }}"
nfd_namespace: node-feature-discovery
nfd_master_deployment_name: nfd-master
nfd_worker_daemonset_name: nfd-worker
