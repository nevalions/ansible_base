---
# Kubernetes Network Configuration (from vault)
kubeadm_pod_subnet: "{{ vault_k8s_pod_subnet }}"
kubeadm_service_subnet: "{{ vault_k8s_service_subnet }}"

# Use DNS or VIP as control plane endpoint for worker joins
# Priority: DNS (if enabled) -> VIP -> empty
kubeadm_control_plane_endpoint_host: >-
  {{
    (vault_k8s_api_dns | default(''))
    if (vault_k8s_use_dns_endpoint | default(false))
    else (vault_k8s_api_vip | default(''))
  }}
kubeadm_control_plane_endpoint: "{{ kubeadm_control_plane_endpoint_host }}:{{ vault_k8s_api_port }}"

# Advertise WireGuard IP for internal communication
# Dynamically finds current host's IP from vault_k8s_control_planes list
# Falls back to ansible_default_ipv4.address if not found
kubeadm_api_server_advertise_address: >-
  {{
    (vault_k8s_control_planes
      | selectattr('name', 'equalto', inventory_hostname)
      | map(attribute='wireguard_ip')
      | list
      | first)
    | default(
        ansible_facts.get(vault_keepalived_vip_interface | default('wg99'), {}).get('ipv4', {}).get('address', '')
      )
    | default(ansible_default_ipv4.address)
  }}

kubeadm_kubelet_extra_args:
  node-ip: "{{ kubeadm_api_server_advertise_address }}"

# Ensure API server certificate includes all control-plane endpoints
# Includes DNS names when DNS endpoint is enabled
kubeadm_api_server_cert_sans: >-
  {{
    (
      [
        kubeadm_control_plane_endpoint_host,
        kubeadm_api_server_advertise_address,
        (vault_k8s_api_dns_name ~ '.' ~ vault_dns_zone) if (vault_k8s_api_dns_name is defined) else ''
      ]
      + (vault_k8s_control_planes | default([]) | map(attribute='wireguard_ip') | list)
      + (vault_k8s_control_planes | default([]) | map(attribute='name') | list)
      + (vault_k8s_control_planes | default([]) | map(attribute='dns_name') | list if (vault_k8s_control_planes[0].dns_name is defined) else [])
      + ([vault_k8s_api_dns_name] if (vault_k8s_api_dns_name is defined) else [])
      + (vault_k8s_control_planes | default([]) | map(attribute='dns_name') | list | map('regex_replace', '^(.*)$', '\\1.' ~ vault_dns_zone) | list if (vault_k8s_control_planes[0].dns_name is defined) else [])
    )
    | reject('equalto', '')
    | select('match', '^(?:\\d{1,3}\\.){3}\\d{1,3}$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$')
    | unique
    | list
  }}

kubeadm_api_version: "v1beta4"

# Calico CNI Configuration (from vault with sensible defaults)
# IMPORTANT: Felix (Calico node agent) resource limits prevent OOM crashes
# Without limits, Felix may be killed by kernel OOM killer during high network traffic
calico_version: "{{ vault_calico_version | default('v3.31.3') }}"
calico_tigera_operator_url: "https://raw.githubusercontent.com/projectcalico/calico/{{ calico_version }}/manifests/tigera-operator.yaml"

# Calico IP Pool Configuration
# These configure IP allocation for cluster workloads
calico_ippool_name: "{{ vault_ipPools }}"
calico_ippool_cidr: "{{ vault_ipPools_cidr }}"
calico_encapsulation: "{{ vault_ipPools_encapsulation }}"
calico_nat_outgoing: "{{ natOutgoing }}"
calico_node_selector: "{{ nodeSelector }}"
calico_block_size: "{{ vault_ipPools_blockSize }}"
calico_mtu: "{{ mtu }}"
calico_node_address_interface: "{{ vault_interface }}"

# Calico Typha Configuration
# Typha reduces API server load in larger clusters
# For small clusters (< 5 nodes), 1 replica is sufficient
# Anti-affinity in the Installation CR prevents port conflicts
calico_typha_replicas: "{{ vault_calico_typha_replicas | default(1) }}"

# Kubeconfig Configuration
kubeconfig_user: "{{ vault_admin_user | default(ansible_user | default(ansible_user_id)) }}"
# Avoid relying on top-level injected facts (ansible_env.*).
kubeconfig_user_home: "{{ ansible_facts.get('env', {}).get('HOME', ansible_user_dir | default('/home/' ~ kubeconfig_user)) }}"
kubeconfig_path: "{{ kubeconfig_user_home }}/.kube/config"

# Refresh API server certs and kubeconfig on re-run
kubeadm_refresh_on_existing: true
